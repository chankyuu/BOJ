# 그래프
## 정의와 표현법
* 그래프의 정의 :
> 정점과 간선으로 이루어진 자료구조
> > 차수(degree) : 각 정점에 대해서 간선으로 연결된 이웃한 정점의 개수

* 무방향 그래프 :
> 방향성이 없는 그래프
 
* 방향 그래프 :
> outdegree : 자기에게서 나가는 간선의 개수
> indegree : 자기에게 들어오는 간선의 개수

* 사이클 :
> 임의의 한 점에서 출발해 자기 자신으로 돌아올 수 있는 경로
> 그래프 안에 사이클이 하나라도 있으면 순환 그래프, 없으면 비순환 그래프

* 완전 그래프 :
> 서로 다른 모든 두 정점 쌍이 간선으로 연결된 그래프

* 연결 그래프 :
> 임의의 두 정점 사이에 경로가 항상 존재하는 그래프

* 단순 그래프 :
> 두 정점 사이의 간선이 1개 이하이고 루프가 존재하지 않는 그래프

* 표헌법1 - 인접행렬 :
> 단순 그래프, 즉 두 정점 사이의 간선이 1개 이하인 그래프라고 할 때 연결된 두 정점에는 1을, 연결되지 않은 두 정점에는 0을 주면 그래프를 표현할 수 있다. 
> 2차원 배열로 표현
> 만약 단순 그래프가 아니라고 한다면 1 혹은 0으로만 나타내지 말고 간선이 3개면 3을 쓰고, 4개면 4를 쓰고 이런 식으로 변형을 시키면 쉽게 해결

* 표현법2 - 인접 리스트 :
> 이 방식은 인접 행렬과 비교했을 때 정점이 많고 간선은 상대적으로 작은 상황에서 공간을 절약할 수 있는 방식
> 경우에 따라 인접 행렬로는 절대 저장이 불가능해 인접 리스트를 써야만 하는 상황이 종종 있어서 반드시 익숙하게 사용할 수 있어야 한다.
> V개의 리스트를 만들어 각 리스트에 자신과 연결된 정점을 넣으면 된다.

## BFS
* BFS 정의 :
> 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘
> BFS 예시 코드 - 연결 그래프에서의 순회
> > vector<int> adj[10];
> >
> > bool vis[10];
> >
> > void bfs() {
> >
> > queue<int> q;
> >
> > q.push(1);  
> >
> > vis[1] = true;
> >
> > while(!q.empty()){
> >
> > int cur = q.front();
> >
> > q.pop();
> >
> > cout << cur << ' ';
> >
> > for(auto nxt : adj[cur]){
> >  if(vis[nxt]) continue;
> >  q.push(nxt);
> >  vis[nxt] = true;
> >  }
> > }
> >}
  
## DFS
* DFS 정의 :
> 다차원 배열에서 각 칸을 방문할 때 깊이를 우선으로 방문하는 알고리즘
> DFS 예시 코드 - 연결 그래프에서의 순회(BFS에서 큐를 스택으로만 바꾸면 됨)
> DFS 예시 코드 - 연결 그래프에서의 순회, 재귀
> > vector<int> adj[10];
> >  
> > bool vis[10];
> >
> > void dfs(int cur) {
> >
> >  vis[cur] = true;
> >
> >  cout << cur << ' ';
> >
> >  for(auto nxt : adj[cur]) {
> >
> >    if(vis[nxt]) continue;
> >
> >    dfs(nxt);
> >
> >  }
> >
> > }
> 재귀 방법과 비재귀 방법이 실제 동작하는 방식에 차이가 있음
> 재귀 방식을 이용할 때 스택에 메모리가 쌓이기 때문에 별도의 스택 메모리 제한이 있으면 재귀 방식을 이용하면 안 됨
  
